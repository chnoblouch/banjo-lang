use std.{memory, memory.PointerIter, system.panic, config, convert.to_repr};

struct Array[T] {
    var data: *T;
    var length: usize;
    var capacity: usize;
    
    pub func new() -> Array[T] {
        return Array[T] {
            data: null,
            length: 0,
            capacity: 0,
        };
    }
    
    pub func from(pointer: *T, length: usize) -> Array[T] {
        var size = length * meta(T).size;
        var data = memory.alloc(size) as *T;
        memory.copy(pointer as addr, data as addr, size);
        
        return Array[T] {
            data,
            length,
            capacity: length,
        };
    }
    
    pub func sized(size: usize) -> Array[T] {
        var data = memory.alloc(size * meta(T).size) as *T;
    
        return Array[T] {
            data: data,
            length: size,
            capacity: size,
        };
    }
    
    pub func __deinit__(self) {
        # meta if type(T).is_struct && type(T).has_method("__deinit__") {
            # for i in 0..self.length as i32 {
                # self.data[i].__deinit__();
            # }
        # }
        
        memory.free(self.data as addr);
    }
    
    pub func append(self, value: T) {    
        self.ensure_capacity(self.length + 1);
        self.data[self.length] = value;
        self.length += 1;
    }
    
    pub func resize(self, length: usize) {
        self.length = length;
        self.ensure_capacity(length);
    }
    
    pub func clear(self) {
        self.length = 0;
    }

    pub func copy(self) -> Array[T] {
        var size = self.length * meta(T).size;
        var data = memory.alloc(size) as *T;
        memory.copy(self.data as addr, data as addr, size);
        
        return Array[T] {
			data,
			length: self.length,
			capacity: self.length,
		};
    }
    
    pub func __index__(self, index: usize) -> *T {
        meta if config.BUILD_CONFIG == config.DEBUG {
            self.check_bounds(index);
        }
    
        return &self.data[index];
    }
    
    pub func __iter__(self) -> PointerIter[T] {
        return PointerIter[T].new(self.data, self.data + self.length);
    }
    
    pub func __add__(self, value: T) -> Array[T] {
        var length = self.length + 1;
        var data = memory.alloc(length * meta(T).size) as *T;
        
        memory.copy(self.data as addr, data as addr, self.length * meta(T).size);
        data[self.length] = value;

        return Array[T] {
            data,
            length,
            capacity: length,
        };
    }

    pub func __add__(self, other: Array[T]) -> Array[T] {
        var length = self.length + other.length;
        var data = memory.alloc(length * meta(T).size) as *T;
        
        memory.copy(self.data as addr, &data[0] as addr, self.length * meta(T).size);
        memory.copy(other.data as addr, &data[self.length] as addr, other.length * meta(T).size);

        return Array[T] {
            data,
            length,
            capacity: length,
        };
    }

    pub func __str__(self) -> String {
        var string = "[";
        
        for i in 0..self.length as i32 {
            string.append(to_repr(self.data[i]));
            
            if i != self.length as i32 - 1 {
                string.append(", ");
            }
        }
        
        string.append(']');
        return string;
    }
    
    func check_bounds(self, index: usize) {
        if index < 0 || index >= self.length {
            panic("index out of bounds");
        }
    }
    
    func ensure_capacity(self, capacity: usize) {
        if self.capacity >= capacity {
            return;
        }
                
        if self.capacity == 0 {
            self.capacity = capacity;
        } else {
            self.capacity = 2 * self.capacity;
        }

        var size = self.capacity * meta(T).size;
        self.data = memory.realloc(self.data as addr, size) as *T;
    }
}
