use os.{IS_UNIX, posix};
use std.system;

meta if IS_UNIX {
    type Error = i32;
    type Socket = i32;

    const SOCKET_INVALID: Socket = 0;
    const SOCKET_ADDRESS_FAMILY_IPV4: i32 = 0;
    const SOCKET_ADDRESS_FAMILY_IPV6: i32 = 0;
    const SOCKET_TYPE_STREAM: i32 = 0;
    const SOCKET_TYPE_DATAGRAM: i32 = 0;
    const SOCKET_PROTOCOL_TCP: i32 = 0;
    const SOCKET_PROTOCOL_UDP: i32 = 0;

    pub func error_last() -> Error {
		return posix.errno();
	}
	
	pub func error_to_string(error: Error) -> String {
		return String.from_cstr(posix.strerror(error));
	}

    pub func io_get_stdin_stream() -> addr {
        return posix.stdin;
    }

    pub func io_get_stdout_stream() -> addr {
        return posix.stdout;
    }

    pub func io_get_stderr_stream() -> addr {
        return posix.stderr;
    }

    pub func thread_spawn(function: func(addr), argument: addr) -> usize {
        var handle: usize;
        var result = posix.pthread_create(&handle, null, function, argument);
        return handle;
    }

    pub func thread_join(handle: usize) {
        var result = posix.pthread_join(handle, null);
    }

    pub func thread_close(handle: usize) {
        # `join` already destroys the handle.
    }

    pub func thread_sleep(milliseconds: u32) {
        var time = posix.Timespec {
            tv_sec: (milliseconds / 1000) as u64,
            tv_nsec: (milliseconds % 1000) as u64 * 1000000
        };
        
        posix.nanosleep(&time, null);
    }

    pub func thread_hardware_concurrency() -> u32 {
        return posix.get_nprocs() as u32;
    }

    pub func time_system_ticks() -> u64 {
        var time: posix.Timespec;
        posix.clock_gettime(posix.CLOCK_REALTIME, &time);
        return 1000000000 * time.tv_sec + time.tv_nsec;
    }
    
    pub func time_system_frequency() -> u64 {
        return 1000000000;
    }
    
    pub func time_system_ticks_since_unix_epoch() -> u64 {
        return 0;
    }

    pub func time_monotonic_ticks() -> u64 {
        var time: posix.Timespec;
        posix.clock_gettime(posix.CLOCK_MONOTONIC, &time);
        return 1000000000 * time.tv_sec + time.tv_nsec;
    }

    pub func time_monotonic_frequency() -> u64 {
        return 1000000000;
    }

    pub func socket_create(address_family: i32, socket_type: i32, protocol: i32) -> Socket {
        panic("unimplemented on this platform");
    }

    pub func socket_set_blocking(socket: Socket, blocking: bool) {
        panic("unimplemented on this platform");
    }

    pub func socket_connect(socket: Socket, host: String, port: u32) -> bool {
        panic("unimplemented on this platform");
    }

    pub func socket_send(socket: Socket, buffer: *u8, size: usize) -> usize except Error {
        panic("unimplemented on this platform");
    }

    pub func socket_recv(socket: Socket, buffer: *u8, size: usize) -> usize except Error {
        panic("unimplemented on this platform");
    }

    pub func socket_close(socket: Socket) {
        panic("unimplemented on this platform");
    }
}
