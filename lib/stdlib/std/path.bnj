use std.{platform, io.Error};

struct Path {
    var path: String;

    pub func new() -> Path {
        return Path { path: "" };
    }

    pub func from[T](ref value: T) -> Path {
        meta if T == Path {
            var path = value.copy();
        } else if T == String {
            var path = Path { path: value.copy() };
        } else if T == *u8 {
            var path = Path { path: String.from(value) };
        }

        path.normalize();
        return path;
    }

    pub func append(mut self, component: String) {
        self.path.append('/');
        self.path.append(component);
    }

    pub func file_name(self) -> String {
        # TODO: Error handling

        try last_separator in self.path.rfind('/') {
            return self.path.substring(last_separator + 1, self.path.length());
        } else {
            return self.path.copy();
        }
    }

    pub func parent(self) -> ?Path {
        # TODO: Support `try` expressions with optionals.

        if self.path.length() == 1 {
            return none;
        }

        try last_separator in self.path.rfind('/') {
            return from(self.path.substring(0, last_separator + 1));
        } else {
            return none;
        }
    }

    pub func exists(self) -> bool except Error {
        try result in platform.path_exists(__builtin_pointer_to(self.path)) {
            return result;
        } except error: platform.ErrorCode {
            return Error.from_platform(error);
        }
    }

    pub func is_file(self) -> bool except Error {
        # TODO: Types other than regular files and directories.

        try result in platform.path_is_file(__builtin_pointer_to(self.path)) {
            return result;
        } except error: platform.ErrorCode {
            return Error.from_platform(error);
        }
    }

    pub func is_dir(self) -> bool except Error {
        try result in platform.path_is_dir(__builtin_pointer_to(self.path)) {
            return result;
        } except error: platform.ErrorCode {
            return Error.from_platform(error);
        }
    }

    pub func list_dir(self) -> Array[Path] except Error {
        try file_names in platform.path_list_dir(__builtin_pointer_to(self.path)) {
            var paths = Array[Path].sized(file_names.length());

            var prefix = self.path.copy() + '/';

            for i in 0..file_names.length() {
                paths[i] = Path.from(prefix.copy() + file_names[i].copy());
            }

            return paths;
        } except error: platform.ErrorCode {
            return Error.from_platform(error);
        }
    }

    pub func create_dir(self) -> void except Error {
        var result = platform.path_create_dir(__builtin_pointer_to(self.path));

        if !result.successful {
            return Error.from_platform(result.unwrap_error());
        }
    }

    pub func remove_file(self) -> void except Error {
        var result = platform.path_remove_file(__builtin_pointer_to(self.path));

        if !result.successful {
            return Error.from_platform(result.unwrap_error());
        }
    }

    pub func remove_dir(self) -> void except Error {
        var result = platform.path_remove_dir(__builtin_pointer_to(self.path));

        if !result.successful {
            return Error.from_platform(result.unwrap_error());
        }
    }

    pub func copy(self) -> Path {
        return Path { path: self.path.copy() };
    }

    pub func str(self) -> String {
        return self.path.copy();
    }

    pub func __str__(self) -> String {
        return self.path.copy();
    }

    pub func __repr__(self, indent: u32) -> String {
        return self.path.__repr__(indent);
    }

    func normalize(mut self) {
        for i in 0..self.path.length() {
            if self.path.bytes()[i] == '\\' {
                self.path.bytes()[i] = '/';
            }
        }

        if self.path.length() > 1 {
            if self.path.bytes()[self.path.length() - 1] == '/' {
                self.path = self.path.substring(0, self.path.length() - 1);
            }
        }
    }
}
