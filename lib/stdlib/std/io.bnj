use std.{platform, numeric, file.File, convert.to_string};
use libc as c;

proto Read {
    pub func read(mut self, data: Slice[u8]) -> usize except Error;

    pub func read_full(mut self, data: Slice[u8]) -> void except Error {
        var num_bytes: usize = 0;

        while num_bytes < data.length {
            var sub_slice = data.sub(num_bytes, data.length - num_bytes);
            num_bytes += try self.read(sub_slice);
        }
    }

    pub func read_u8(mut self) -> u8 except Error {
        var value: u8;
        try self.read_full(Slice[u8].new(&value, 1));
        return value;
    }

    pub func read_u16_be(mut self) -> u16 except Error {
        var bytes: [u8; 2];
        try self.read_full(Slice[u8].new(&bytes[0], 2));
        return numeric.u16_from_bytes_be(bytes);
    }

    pub func read_u16_le(mut self) -> u16 except Error {
        var bytes: [u8; 2];
        try self.read_full(Slice[u8].new(&bytes[0], 2));
        return numeric.u16_from_bytes_le(bytes);
    }

    pub func read_u16_native(mut self) -> u16 except Error {
        var value: u16;
        try self.read_full(Slice[u8].new(&value as *u8, 2));
        return value;
    }

    pub func read_u32_be(mut self) -> u32 except Error {
        var bytes: [u8; 4];
        try self.read_full(Slice[u8].new(&bytes[0], 4));
        return numeric.u32_from_bytes_be(bytes);
    }

    pub func read_u32_le(mut self) -> u32 except Error {
        var bytes: [u8; 4];
        try self.read_full(Slice[u8].new(&bytes[0], 4));
        return numeric.u32_from_bytes_le(bytes);
    }

    pub func read_u32_native(mut self) -> u32 except Error {
        var value: u32;
        try self.read_full(Slice[u8].new(&value as *u8, 4));
        return value;
    }

    pub func read_u64_be(mut self) -> u64 except Error {
        var bytes: [u8; 8];
        try self.read_full(Slice[u8].new(&bytes[0], 8));
        return numeric.u64_from_bytes_be(bytes);
    }

    pub func read_u64_le(mut self) -> u64 except Error {
        var bytes: [u8; 8];
        try self.read_full(Slice[u8].new(&bytes[0], 8));
        return numeric.u64_from_bytes_le(bytes);
    }

    pub func read_u64_native(mut self) -> u64 except Error {
        var value: u64;
        try self.read_full(Slice[u8].new(&value as *u8, 8));
        return value;
    }

    pub func read_line(mut self) -> String except Error {
        # TODO: Buffering

        var line = "";

        var char: u8;
        try self.read_full(Slice[u8].new(&char, 1));

        while char != '\r' && char != '\n' {
            line += char;
            try self.read_full(Slice[u8].new(&char, 1));
        }

        return line;
    }
}

proto Write {
    pub func write(mut self, data: Slice[u8]) -> usize except Error;

    pub func write_u8(mut self, value: u8) -> usize except Error {
        return self.write(Slice[u8].new(&value, 1));
    }

    pub func write_u16_be(mut self, value: u16) -> usize except Error {
        var data = numeric.u16_to_bytes_be(value);
        return self.write(Slice[u8].new(&data[0], 2));
    }

    pub func write_u16_le(mut self, value: u16) -> usize except Error {
        var data = numeric.u16_to_bytes_le(value);
        return self.write(Slice[u8].new(&data[0], 2));
    }

    pub func write_u16_native(mut self, value: u16) -> usize except Error {
        return self.write(Slice[u8].new(&value as *u8, 2));
    }

    pub func write_u32_be(mut self, value: u32) -> usize except Error {
        var data = numeric.u32_to_bytes_be(value);
        return self.write(Slice[u8].new(&data[0], 4));
    }

    pub func write_u32_le(mut self, value: u32) -> usize except Error {
        var data = numeric.u32_to_bytes_le(value);
        return self.write(Slice[u8].new(&data[0], 4));
    }

    pub func write_u32_native(mut self, value: u32) -> usize except Error {
        return self.write(Slice[u8].new(&value as *u8, 4));
    }

    pub func write_u64_be(mut self, value: u64) -> usize except Error {
        var data = numeric.u64_to_bytes_be(value);
        return self.write(Slice[u8].new(&data[0], 8));
    }

    pub func write_u64_le(mut self, value: u64) -> usize except Error {
        var data = numeric.u64_to_bytes_le(value);
        return self.write(Slice[u8].new(&data[0], 8));
    }

    pub func write_u64_native(mut self, value: u64) -> usize except Error {
        return self.write(Slice[u8].new(&value as *u8, 8));
    }

    pub func write_string(mut self, string: StringSlice) -> usize except Error {
        return self.write(Slice[u8].new(string.data, string.length));
    }

    pub func write_cstring(mut self, data: *u8) -> usize except Error {
        var length = c.strlen(data);
        return self.write(Slice[u8].new(data, length));
    }
}

proto Seek {
    enum Origin {
        START,
        END,
        CURRENT,
    }

    pub func position(self) -> u64 except Error;
    pub func seek(mut self, offset: i64, origin: Origin) -> void except Error;
}

struct Error {
    enum Kind {
        NOT_FOUND,
        PERMISSION_DENIED,
        ALREADY_EXISTS,
        UNKNOWN,
    }

    var kind: Kind;
    var code: ?platform.ErrorCode;

    pub func new(kind: Kind) -> Error {
        return Error {
            kind,
            code: none,
        };
    }

    pub func from_platform(code: platform.ErrorCode) -> Error {
        return Error {
            kind: platform.error_kind(code),
            code,
        };
    }

    pub func last() -> Error {
        return from_platform(platform.error_last());
    }

    pub func message(self) -> ?String {
        try code in self.code {
            return platform.error_message(code);
        } else {
            return none;
        }
    }

    pub func __str__(self) -> String {
        try message in self.message() {
            return to_string(self.kind) + " (" + message + ")";
        } else {
            return to_string(self.kind);
        }
    }
}

struct StandardInStream: Read {
    var file: File;

    pub func from(stream: addr) -> StandardInStream {
        return StandardInStream {
            file: File { stream },
        };
    }

    pub func read(self, data: Slice[u8]) -> usize except Error {
        return self.file.read(data);
    }
}

struct StandardOutStream: Write {
    var file: File;

    pub func from(stream: addr) -> StandardOutStream {
        return StandardOutStream {
            file: File { stream },
        };
    }

    pub func write(self, data: Slice[u8]) -> usize except Error {
        return self.file.write(data);
    }
}

pub func stdin() -> StandardInStream {
    return StandardInStream.from(platform.io_get_stdin_stream());
}

pub func stdout() -> StandardOutStream {
    return StandardOutStream.from(platform.io_get_stdout_stream());
}

pub func stderr() -> StandardOutStream {
    return StandardOutStream.from(platform.io_get_stderr_stream());
}
