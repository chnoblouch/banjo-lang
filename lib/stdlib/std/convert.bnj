use std.memory;
use c.lib.{stdlib.strtod, string.isspace};
use internal.runtime;

pub func to_string[T](ref value: T) -> String {
    meta if T == String {
        return value.copy();
    } else if T == *u8 {
        return String.from(value);
    } else if T == i8 || T == i16 || T == i32 || T == i64 {
        return i64_to_string(value as i64);
    } else if T == u16 || T == u32 || T == u64 || T == usize {
        return u64_to_string(value as u64);
    } else if T == f32 || T == f64 {
        return f64_to_string(value as f64);
    } else if T == u8 {
        return char_to_string(value);
    } else if T == bool {
        return bool_to_string(value);
    } else if meta(T).has_method("__str__") {
        return value.__str__();
    } else if meta(T).is_struct {
        return struct_to_repr(value, 0);
    } else if meta(T).is_enum {
        return enum_to_repr(value);
    } else {
        return "<?>";
    }
}

pub func to_repr[T](ref value: T) -> String {
    return to_repr_indent(value, 0);
}

pub func to_repr_indent[T](ref value: T, indent: u32) -> String {
    meta if T == String {
        return "\"" + value.copy() + "\"";
    }  else if T == u8 {
        return "\'" + char_to_string(value) + "\'";
    } else if meta(T).has_method("__repr__") {
        return value.__repr__(indent);
    } else if meta(T).is_struct {
        return struct_to_repr(value, indent);
    } else {
        return to_string(value);
    }
}

pub func parse_u64(string: StringSlice) -> ?u64 {
    # TODO: Better validation (overflow)

    var index: i32 = string.length as i32 - 1;
    var place_value: u64 = 1;
    var value: u64 = 0;

    while index >= 0 {
        var char = string.data[index];

        if !(char >= '0' && char <= '9') {
            return none;
        }

        value += place_value * (char - '0') as u64;
        place_value *= 10;
        index -= 1;
    }

    return value;
}

pub func parse_i64(string: StringSlice) -> ?i64 {
    # TODO: Better validation (overflow)

    var sign: i64 = 1;
    var last_index = 0;

    if string.data[0] == '-' {
        sign = -1 as i64;
        last_index = 1;
    }

    var index: i32 = string.length as i32 - 1;
    var place_value: i64 = 1;
    var value: i64 = 0;

    while index >= last_index {
        var char = string.data[index];

        if !(char >= '0' && char <= '9') {
            return none;
        }

        value += place_value * (char - '0') as i64;
        place_value *= 10;
        index -= 1;
    }

    return sign * value;
}

pub func parse_f64(string: StringSlice) -> ?f64 {
    if string.length == 0 || string.length >= 1024 {
        return none;
    }

    if isspace(string.data[0] as i32) != 0 {
        return none;
    }

    var c_string: [u8; 1024];
    memory.copy(string.data, &c_string[0], string.length);
    c_string[string.length] = '\0';

    var end: *u8 = null;
    var result = strtod(&c_string[0], &end);

    if end != &c_string[string.length] {
        return none;
    }

    return result;
}

func i64_to_string(value: i64) -> String {
    var capacity: usize = 32;
    var buffer: [u8; 32];
    var length: usize = 0;
    
    var remainder: u64;
    var negative: bool;
    
    if value >= 0 {
        remainder = value as u64;
        negative = false;
    } else {
        remainder = -value as u64;
        negative = true;
    }
    
    while true {
        length += 1;
        buffer[capacity - length] = (remainder % 10) as u8 + '0';
        remainder /= 10;
        
        if remainder == 0 {
            break;
        }
    }
    
    if negative {
        length += 1;
        buffer[capacity - length] = '-';
    }
    
    var slice = StringSlice.new(&buffer[capacity - length], length);
    return String.from(slice);
}

func u64_to_string(value: u64) -> String {
    var capacity: usize = 32;
    var buffer: [u8; 32];
    var length: usize = 0;
    
    var remainder = value;
    
    while true {
        length += 1;
        buffer[capacity - length] = (remainder % 10) as u8 + '0';
        remainder /= 10;
        
        if remainder == 0 {
            break;
        }
    }
    
    var slice = StringSlice.new(&buffer[capacity - length], length);
    return String.from(slice);
}

func f64_to_string(value: f64) -> String {
    var buffer: [u8; 64];
    runtime.f64_to_string(value, &buffer[0], 64);
    return String.from(&buffer[0]);
}

func char_to_string(value: u8) -> String {
    var string = String.new();
    string.append(value);
    return string;
}

func bool_to_string(value: bool) -> String {
    if value {
        return "true";
    } else {
        return "false";
    }
}

func struct_to_repr[T](ref struct_: T, indent: u32) -> String {
    var string = meta(T).name + " {\n";

    meta for field_name in meta(T).fields {    
        for i in 0..indent + 1 {
            string += "  ";
        }

        string += field_name;
        string += ": ";
        string += to_repr_indent(meta(struct_).field(field_name), indent + 1);
        string += ",\n";
    }

    for i in 0..indent {
        string += "  ";
    }

    string += '}';
    return string;
}

func enum_to_repr[T](enum_: T) -> String {
    var variant_name: String;
    
    meta for variant in meta(T).variants {
        # TODO: This cast to 'i32' should not be necessary.
        if enum_ as i32 == variant.1 {
            variant_name = variant.0;
        }
    }

    # TODO: Maybe don't include the enum name.
    return meta(T).name + "." + variant_name;
}
