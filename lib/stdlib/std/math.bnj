use libc as c;

const PI32: f32 = 3.14159;

pub func abs(x: f64) -> f64 {
    if x >= 0.0 {
        return x;
    } else {
        return -x;
    }
}

pub func sqrt(x: f64) -> f64 {
    return c.sqrt(x);
}

pub func sin(x: f64) -> f64 {
    return c.sin(x);
}

pub func cos(x: f64) -> f64 {
    return c.cos(x);
}

pub func tan(x: f64) -> f64 {
    return c.tan(x);
}

pub func asin(x: f64) -> f64 {
    return c.asin(x);
}

pub func acos(x: f64) -> f64 {
    return c.acos(x);
}

pub func atan(x: f64) -> f64 {
    return c.atan(x);
}

pub func atan2(y: f64, x: f64) -> f64 {
    return c.atan2(y, x);
}

pub func abs(x: f32) -> f32 {
    if x >= 0.0 {
        return x;
    } else {
        return -x;
    }
}

pub func sqrt(x: f32) -> f32 {
    return c.sqrtf(x);
}

pub func sin(x: f32) -> f32 {
    return c.sinf(x);
}

pub func cos(x: f32) -> f32 {
    return c.cosf(x);
}

pub func tan(x: f32) -> f32 {
    return c.tanf(x);
}

pub func asin(x: f32) -> f32 {
    return c.asinf(x);
}

pub func acos(x: f32) -> f32 {
    return c.acosf(x);
}

pub func atan(x: f32) -> f32 {
    return c.atanf(x);
}

pub func atan2(y: f32, x: f32) -> f32 {
    return c.atan2f(y, x);
}

pub func deg2rad(deg: f32) -> f32 {
    return deg * PI32 / 180.0;
}

pub func rad2deg(rad: f32) -> f32 {
    return rad * 180.0 / PI32;
}

pub func min[T](a: T, b: T) -> T {
    if a < b {
        return a;
    } else {
        return b;
    }
}

pub func max[T](a: T, b: T) -> T {
    if a > b {
        return a;
    } else {
        return b;
    }
}

pub func clamp[T](v: T, minv: T, maxv: T) -> T {
    return min[T](maxv, max[T](minv, v));
}
