use std.{
    platform,
    memory,
    convert,
    path.Path,
    io.{Read, Write, Seek, Error},
};

use libc as c;

struct File: Read, Write, Seek {
    enum Mode {
        READ,
        WRITE,
        APPEND,
        READ_WRITE,
        READ_WRITE_ERASE,
        READ_APPEND,
    }

    var stream: addr;

    pub func open[P](path: P, mode: Mode) -> File except Error {
        var c_mode: *u8;

        if mode == Mode.READ {
            c_mode = "rb";
        } else if mode == Mode.WRITE {
            c_mode = "wb";
        } else if mode == Mode.APPEND {
            c_mode = "ab";
        } else if mode == Mode.READ_WRITE {
            c_mode = "r+b";
        } else if mode == Mode.READ_WRITE_ERASE {
            c_mode = "w+b";
        } else if mode == Mode.READ_APPEND {
            c_mode = "a+b";
        }

        var path_cstring = Path.from(path).str().to_cstring();
        var stream = c.fopen(path_cstring.data(), c_mode);

        if stream == null {
            return Error.last();
        }

        return File { stream };
    }

    pub func read_all[P](path: P) -> Array[u8] except Error {
        var file = try open(path, File.Mode.READ);
        try file.seek(0, .END);
        var size = try file.position() as usize;
        try file.seek(0, .START);

        var buffer = Array[u8].sized(size);
        try file.read_full(buffer.slice);
        return buffer;
    }

    pub func read_all_string[P](path: P) -> String except Error {
        var file = try open(path, File.Mode.READ);
        try file.seek(0, .END);
        var size = try file.position() as usize;
        try file.seek(0, .START);

        var string = String {
            slice: StringSlice {
                data: memory.alloc(size) as *u8,
                length: size,
            },
            capacity: size,
        };

        try file.read_full(Slice[u8].new(string.bytes(), string.length()));
        return string;
    }

    pub func read(self, data: Slice[u8]) -> usize except Error {
        var result = c.fread(data.data, 1, data.length, self.stream);

        if result == data.length || c.feof(self.stream) != 0 {
            return result;
        } else {
            return Error.last();
        }
    }

    pub func write(self, data: Slice[u8]) -> usize except Error {
        var result = c.fwrite(data.data, 1, data.length, self.stream);

        if result == data.length {
            return result;
        } else {
            return Error.last();
        }
    }

    pub func position(self) -> u64 except Error {
        # TODO: Actually support 64-bit offsets.

        var result = c.ftell(self.stream);

        if result != 0xFFFFFFFF {
            return result as u64;
        } else {
            return Error.last();
        }
    }

    pub func seek(mut self, offset: i64, origin: Seek.Origin) -> void except Error {
        # TODO: Actually support 64-bit offsets.

        var libc_origin: i32 = 0;

        if origin == .START {
            libc_origin = c.SEEK_SET;
        } else if origin == .END {
            libc_origin = c.SEEK_END;
        } else if origin == .CURRENT {
            libc_origin = c.SEEK_CUR;
        }

        var result = c.fseek(self.stream, offset as c.Long, libc_origin);

        if result == 0 {
            return undefined;
        } else {
            return Error.last();
        }
    }

    pub func flush(self) {
        # TODO: Error handling

        c.fflush(self.stream);
    }

    func __deinit__(self) {
        c.fclose(self.stream);
    }
}
