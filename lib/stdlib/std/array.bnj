use std.{
    memory.{PointerMoveIter, PointerRefIter},
    memory,
    convert,
};

struct Array[T] {
    var slice: Slice[T];
    var capacity: usize;

    pub func new() -> Array[T] {
        return Array[T] {
            slice: Slice[T].new_empty(),
            capacity: 0,
        };
    }

    pub func from(pointer: *T, length: usize) -> Array[T] {
        var size = length * meta(T).size;
        var data = memory.alloc(size) as *T;
        memory.copy(pointer, data, size);

        return Array[T] {
            slice: Slice[T].new(data, length),
            capacity: length,
        };
    }

    pub func sized(length: usize) -> Array[T] {
        var data = memory.alloc(length * meta(T).size) as *T;

        return Array[T] {
            slice: Slice[T].new(data, length),
            capacity: length,
        };
    }

    pub func __deinit__(self) {
        for i in 0..self.slice.length {
            __builtin_deinit(self.slice.data[i]);
        }

        memory.free(self.slice.data);
    }

    pub func slice(self) -> Slice[T] {
        return self.slice;
    }

    pub func data(self) -> *T {
        return self.slice.data;
    }

    pub func length(self) -> usize {
        return self.slice.length;
    }

    pub func append(mut self, value: T) {
        self.ensure_capacity(self.slice.length + 1);
        self.slice.data[self.slice.length] = value;
        self.slice.length += 1;
    }

    pub func insert(mut self, index: usize, value: T) {
        if index > self.slice.length {
            panic(
                "insertion index out of bounds (index: " +
                convert.to_string(index) +
                ", array length: " +
                convert.to_string(self.slice.length) +
                ")",
            );
        }

        self.ensure_capacity(self.slice.length + 1);

        var num_bytes = meta(T).size * (self.slice.length - index);
        memory.copy(&self.slice.data[index], &self.slice.data[index + 1], num_bytes);

        self.slice.data[index] = value;
        self.slice.length += 1;
    }

    pub func remove(mut self, index: usize) {
        if index >= self.slice.length {
            panic(
                "index to remove out of bounds (index: " +
                convert.to_string(index) +
                ", array length: " +
                convert.to_string(self.slice.length) +
                ")",
            );
        }
        
        var num_bytes = meta(T).size * (self.slice.length - index);
        memory.copy(&self.slice.data[index + 1], &self.slice.data[index], num_bytes);

        self.slice.length -= 1;
    }

    pub func resize(mut self, length: usize) {
        self.slice.length = length;
        self.ensure_capacity(length);
    }

    pub func clear(mut self) {
        self.slice.length = 0;
    }

    pub func copy(self) -> Array[T] {
        var size = self.slice.length * meta(T).size;
        var data = memory.alloc(size) as *T;
        memory.copy(self.slice.data, data, size);

        return Array[T] {
            slice: Slice[T].new(data, self.slice.length),
            capacity: self.slice.length,
        };
    }

    pub func find(self, predicate: |value: ref T| -> bool) -> ?usize {
        for i in 0..self.slice.length {
            if predicate(self.slice.data[i]) {
                return i;
            }
        }
        
        return none;
    }

    pub func filter(@byval self, predicate: |value: ref T| -> bool) -> Array[T] {
        var result: Array[T] = [];
        
        for value in self {
            if predicate(value) {
                result.append(value);
            }
        }
        
        return result;
    }

    pub func map[R](self, function: |value: ref T| -> R) -> Array[R] {
        var result = Array[R].sized(self.slice.length);

        for i in 0..self.slice.length {
            result[i] = function(self.slice.data[i]);
        }

        return result;
    }

    pub func __index__(self, index: usize) -> ref T {
        return self.slice.__index__(index);
    }

    pub func __mutindex__(mut self, index: usize) -> ref mut T {
        return self.slice.__mutindex__(index);
    }

    pub func __iter__(@[byval, unmanaged] self) -> PointerMoveIter[T] {
        return self.slice.__iter__();
    }

    pub func __refiter__(self) -> PointerRefIter[T] {
        return self.slice.__refiter__();
    }

    pub func __mutiter__(mut self) -> PointerRefIter[T] {
        return self.slice.__mutiter__();
    }

    pub func __add__(mut self, value: T) -> Array[T] {
        var length = self.slice.length + 1;
        var data = memory.alloc(length * meta(T).size) as *T;

        memory.copy(self.slice.data, data, self.slice.length * meta(T).size);
        data[self.slice.length] = value;

        return Array[T] {
            slice: Slice[T].new(data, length),
            capacity: length,
        };
    }

    pub func __add__(mut self, other: Array[T]) -> Array[T] {
        var length = self.slice.length + other.slice.length;
        var data = memory.alloc(length * meta(T).size) as *T;

        memory.copy(self.slice.data, &data[0], self.slice.length * meta(T).size);
        memory.copy(other.slice.data, &data[self.slice.length], other.slice.length * meta(T).size);

        return Array[T] {
            slice: Slice[T].new(data, length),
            capacity: length,
        };
    }

    pub func __str__(self) -> String {
        return self.slice.__str__();
    }

    pub func __repr__(self, indent: u32) -> String {
        return self.slice.__repr__(indent);
    }

    func ensure_capacity(mut self, capacity: usize) {
        if self.capacity >= capacity {
            return;
        }

        if self.capacity == 0 {
            self.capacity = capacity;
        } else {
            self.capacity = 2 * self.capacity;
        }

        var size = self.capacity * meta(T).size;
        self.slice.data = memory.realloc(self.slice.data, size) as *T;
    }
}
