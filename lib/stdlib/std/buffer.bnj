use std.{io, memory};

struct Buffer: io.Read, io.Write, io.Seek {
    var data: Array[u8];
    var position_: usize;

    pub func new() -> Buffer {
        return Buffer {
            data: [],
            position_: 0,
        };
    }

    pub func read(mut self, data: Slice[u8]) -> usize except io.Error {
        if self.position_ + data.length > self.data.length() {
            return io.Error { handle: undefined };
        }

        memory.copy(&self.data[self.position_], data.data, data.length);
        return data.length;
    }

    pub func write(mut self, data: Slice[u8]) -> usize except io.Error {
        if self.position_ + data.length > self.data.length() {
            self.data.resize(self.position_ + data.length);
        }

        memory.copy(data.data, &self.data[self.position_], data.length);
        self.position_ += data.length;

        return data.length;
    }

    pub func position(self) -> u64 except io.Error {
        return self.position_ as u64;
    }

    pub func seek(mut self, offset: i64, origin: io.Seek.Origin) -> void except io.Error {
        if origin == .START {
            # TODO: Check non-negative
            self.position_ = offset as usize;
        } else if origin == .END {
            self.position_ = self.data.length();
        } else if origin == .CURRENT {
            # TODO: Out of bounds check, casting
            self.position_ = (self.position_ as i64 + offset) as usize;
        }

        return undefined;
    }
}
