use std.config;
use libc as c;

meta if config.OS == config.LINUX {
    const ENOENT: i32 = 0x02;
    const EACCES: i32 = 0x0D;

    native func __errno_location() -> *i32;

    pub func errno() -> *i32 {
        return __errno_location();
    }

    meta if config.ARCH == config.X86_64 {
        struct Stat {
            var dev: u64;
            var ino: u64;
            var nlink: u64;
            var mode: u32;
            var uid: u32;
            var gid: u32;
            var pad0: i32;
            var rdev: u64;
            var size: i64;
            var blksize: i64;
            var blocks: i64;
            var atim: Timespec;
            var mtim: Timespec;
            var ctim: Timespec;
            var reserved: [i64; 3];
        }

        struct Dirent {
            var ino: u64;
            var off: i64;
            var reclen: u16;
            var type_: u8;
            var name: [u8; 256];
        }
    } else if config.ARCH == config.AARCH64 {
        struct Stat {
            var dev: u64;
            var ino: u64;
            var mode: u32;
            var nlink: u32;
            var uid: u32;
            var gid: u32;
            var rdev: u64;
            var pad1: u64;
            var size: i64;
            var blksize: i32;
            var pad2: i32;
            var blocks: i64;
            var atim: Timespec;
            var mtim: Timespec;
            var ctim: Timespec;
            var reserved: [i32; 2];
        }

        struct Dirent {
            var ino: u64;
            var off: i64;
            var reclen: u16;
            var type_: u8;
            var name: [u8; 256];
        }
    }

    const F_OK: i32 = 0;

    const S_IFMT: u32 = 0o170000;
    const S_IFSOCK: u32 = 0o140000;
    const S_IFLNK: u32 = 0o120000;
    const S_IFREG: u32 = 0o100000;
    const S_IFBLK: u32 = 0o600000;
    const S_IFDIR: u32 = 0o040000;
    const S_IFCHR: u32 = 0o020000;
    const S_IFIFO: u32 = 0o010000;

    native var stdin: addr;
    native var stdout: addr;
    native var stderr: addr;

    # FIXME: This size is definitely only 40 on x86-64.
    type PthreadMutex = [u8; 40];

    type ClockId = u64;

    struct Timespec {
        var tv_sec: c.LongLong;
        var tv_nsec: c.Long;
    }

    const CLOCK_REALTIME: ClockId = 0;
    const CLOCK_MONOTONIC: ClockId = 1;

    struct Sockaddr {
        var family: u16;
        var data: [u8; 14];
    }

    struct Addrinfo {
        var flags: i32;
        var family: i32;
        var socktype: i32;
        var protocol: i32;
        var addrlen: u32;
        var addr_: *Sockaddr;
        var canonname: *u8;
        var next: *Addrinfo;
    }

    const MSG_NOSIGNAL: i32 = 0x4000;
    const AF_INET: i32 = 2;
    const AF_INET6: i32 = 10;
    const SOCK_STREAM: i32 = 1;
    const SOCK_DGRAM: i32 = 2;
    const IPPROTO_TCP: i32 = 6;
    const IPPROTO_UDP: i32 = 17;
    const SHUT_RD: i32 = 0;
    const SHUT_WR: i32 = 1;
    const SHUT_RDWR: i32 = 2;
}
